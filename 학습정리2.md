## \***\*(1) Object.defineProperty 이해하기\*\***

```jsx
let a = 10
const state = {}
Object.defineProperty(state, 'a', {
  get() {
    console.log(`현재 a의 값은 ${a} 입니다.`)
    return a
  },
  set(value) {
    a = value
    console.log(`변경된 a의 값은 ${a} 입니다.`)
  }
})

console.log(`state.a = ${state.a}`)
state.a = 100
```

> 위 코드는 `Object.defineProperty()`를 사용하여 `state` 객체의 `a` 속성을 정의하고 있습니다.
>
> `let a = 10;` 구문을 통해 `a` 변수를 초기화합니다. 이후, `state` 객체를 생성합니다.
>
> `Object.defineProperty()`를 사용하여 `state` 객체의 `a` 속성을 정의합니다.
>
> 이 속성은 `get` 메서드와 `set` 메서드를 가지고 있습니다. `get` 메서드는 `state.a` 속성을 읽을 때 호출되며, `set` 메서드는 `state.a` 속성에 값을 할당할 때 호출됩니다.
>
> `get` 메서드는 `console.log()`를 사용하여 현재 `a` 값이 어떤지 출력한 후, `a` 값을 반환합니다. `set` 메서드는 새로운 값을 `a`에 할당한 후, `console.log()`를 사용하여 변경된 `a` 값이 어떤지 출력합니다.
>
> 마지막으로 `console.log()`를 사용하여 `state.a` 속성 값을 출력합니다. 이 때 `get` 메서드가 호출되며, 현재 `a` 값이 출력됩니다. 이후 `state.a = 100;` 구문을 통해 `set` 메서드가 호출되며, `a` 값이 `100`으로 변경되고 변경된 값을 출력합니다.

🤔 get, set을 직접 호출하지 않았는데 어떻게 작동하는 걸까?

> `set` 메서드와 `get` 메서드는 `Object.defineProperty()` 메서드에서 제공하는 내장 함수입니다. 이 메서드를 사용하여 객체의 속성을 정의할 때, 속성에 대한 값을 가져오거나 할당할 때마다 이들 내장 함수가 호출됩니다.
>
> `set` 메서드는 속성에 값을 할당할 때 호출되며, `get` 메서드는 속성 값을 가져올 때 호출됩니다. 이러한 내장 함수를 사용하면 속성 값을 가져오거나 할당하기 전에 추가적인 작업을 수행할 수 있습니다. 예를 들어, `set` 메서드에서는 새로운 값이 할당되기 전에 유효성 검사를 수행할 수 있습니다.
>
> 따라서, `set` 메서드와 `get` 메서드는 `Object.defineProperty()` 메서드에서 제공하는 내장 함수로, 객체의 속성에 대한 값을 가져오거나 할당할 때마다 호출됩니다.

```jsx
let currentObserver = null

const observe = fn => {
  currentObserver = fn
  fn()
  currentObserver = null
}

// 객체를 세팅하는 함수 (프록시를 설정)
const observable = obj => {
  Object.keys(obj).forEach(key => {
    let _value = obj[key]
    const observers = new Set()
    // get a : Scopes : Closure { ..., observers: ... }

    Object.defineProperty(obj, key, {
      get() {
        if (currentObserver) observers.add(currentObserver)
        return _value
      },

      set(value) {
        _value = value
        observers.forEach(fn => fn())
      }
    })
  })
  return obj
}
```

🤔 `currentObsrever = fn` 할당을 했는데 `fn()`으로 실행하는 이유?

> `currentObserver` 변수에 함수를 할당하는 이유는 이후 `set` 함수에서 상태가 변경될 때, 해당 상태를 의존하는 함수들을 호출하기 위함입니다. 따라서 `currentObserver` 변수에 할당된 함수를 실행하는 것이 필요합니다.
>
> 하지만 `currentObserver` 변수에 할당된 함수는 사용자가 전달한 콜백 함수이므로, 이 함수가 항상 매개변수를 받지 않는다는 보장이 없습니다. 따라서 `currentObserver()`와 같이 `currentObserver` 변수를 함수처럼 호출하면 오류가 발생할 수 있습니다.
>
> 예를 들어, `currentObserver` 변수에 할당된 함수가 매개변수를 받는 경우에는 `currentObserver()`와 같이 호출하면 오류가 발생합니다. 따라서 `fn()`과 같이 함수를 실행하는 것이 적절합니다.

🤔 `currentObserver = null`하는 이유?

> `currentObserver` 변수는 전역 변수이므로, `observe` 함수가 실행될 때마다 값이 덮어씌워집니다. 만약 `fn` 함수를 실행하면서 `currentObserver` 변수를 초기화하지 않으면, 다음에 `observe` 함수가 실행될 때 이전에 실행된 함수가 여전히 `currentObserver` 변수에 저장되어 있을 수 있습니다. 이러한 경우에는 `fn` 함수의 실행 결과가 예상과 다를 수 있으며, 이를 방지하기 위해 `fn` 함수 실행 이후에 `currentObserver` 변수를 `null`로 초기화합니다.
>
> 즉, `currentObserver` 변수는 오직 `observe` 함수 내에서만 사용되는 변수이며, `fn` 함수 실행 이후에 초기화하는 것은 `currentObserver` 변수가 다른 함수 실행에 영향을 미치는 것을 방지하기 위함입니다.

```jsx
const 상태 = observable({ a: 10, b: 20 })
// observable의 get, set 메서드가 실행되는 것이 아니다.
// a 속성을 정의하는 것이다.

// console.log(상태)를 해보면
// a, b, get a, set a, get b, set b 프로퍼티(?)들이 있다.

observe(() => console.log(`a = ${상태.a}`))
// 상태.a -> a에 대한 getter가 실행된다.
// 근데 getter에는 함수를 등록하는 로직이 있어서 함수가 등록된다.
// 여기서 함수는 () => console.log( ... )

observe(() => console.log(`b = ${상태.b}`))
observe(() => console.log(`a + b = ${상태.a} + ${상태.b}`))
observe(() => console.log(`a * b = ${상태.a} + ${상태.b}`))
observe(() => console.log(`a - b = ${상태.a} + ${상태.b}`))

상태.a = 100
상태.b = 200
```
